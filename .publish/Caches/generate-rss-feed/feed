{"itemCount":6,"config":{"ttlInterval":250,"maximumItemCount":100,"targetPath":"feed.rss"},"feed":"<?xml version=\"1.0\" encoding=\"UTF-8\"?><rss version=\"2.0\" xmlns:atom=\"http:\/\/www.w3.org\/2005\/Atom\" xmlns:content=\"http:\/\/purl.org\/rss\/1.0\/modules\/content\/\"><channel><title>Matias Glessi | iOS Engineer<\/title><description><\/description><link>https:\/\/matiasglessi.com<\/link><language>en<\/language><lastBuildDate>Mon, 6 Jun 2022 12:21:41 -0300<\/lastBuildDate><pubDate>Mon, 6 Jun 2022 12:21:41 -0300<\/pubDate><ttl>250<\/ttl><atom:link href=\"https:\/\/matiasglessi.com\/feed.rss\" rel=\"self\" type=\"application\/rss+xml\"\/><item><guid isPermaLink=\"true\">https:\/\/matiasglessi.com\/posts\/Copia%20de%20first-post2%202<\/guid><title>Test Doubles in Swift<\/title><description>Test doubles are the unique way of handling mocking for testing porpuses, learn how to work with them in this article.<\/description><link>https:\/\/matiasglessi.com\/posts\/Copia%20de%20first-post2%202<\/link><pubDate>Wed, 23 Feb 2022 21:21:00 -0300<\/pubDate><content:encoded><![CDATA[<h1>Test Doubles in Swift<\/h1><p>My first post's text.<\/p>]]><\/content:encoded><\/item><item><guid isPermaLink=\"true\">https:\/\/matiasglessi.com\/posts\/Copia%20de%20first-post2%203<\/guid><title>Test Doubles in Swift<\/title><description>Test doubles are the unique way of handling mocking for testing porpuses, learn how to work with them in this article.<\/description><link>https:\/\/matiasglessi.com\/posts\/Copia%20de%20first-post2%203<\/link><pubDate>Wed, 23 Feb 2022 21:21:00 -0300<\/pubDate><content:encoded><![CDATA[<h1>Test Doubles in Swift<\/h1><p>My first post's text.<\/p>]]><\/content:encoded><\/item><item><guid isPermaLink=\"true\">https:\/\/matiasglessi.com\/posts\/Copia%20de%20first-post2%204<\/guid><title>Test Doubles in Swift<\/title><description>Test doubles are the unique way of handling mocking for testing porpuses, learn how to work with them in this article.<\/description><link>https:\/\/matiasglessi.com\/posts\/Copia%20de%20first-post2%204<\/link><pubDate>Wed, 23 Feb 2022 21:21:00 -0300<\/pubDate><content:encoded><![CDATA[<h1>Test Doubles in Swift<\/h1><p>My first post's text.<\/p>]]><\/content:encoded><\/item><item><guid isPermaLink=\"true\">https:\/\/matiasglessi.com\/posts\/Copia%20de%20first-post2<\/guid><title>Test Doubles in Swift<\/title><description>Test doubles are the unique way of handling mocking for testing porpuses, learn how to work with them in this article.<\/description><link>https:\/\/matiasglessi.com\/posts\/Copia%20de%20first-post2<\/link><pubDate>Wed, 23 Feb 2022 21:21:00 -0300<\/pubDate><content:encoded><![CDATA[<h1>Test Doubles in Swift<\/h1><p>My first post's text.<\/p>]]><\/content:encoded><\/item><item><guid isPermaLink=\"true\">https:\/\/matiasglessi.com\/posts\/first-post<\/guid><title>Test Doubles in Swift<\/title><description>Test doubles are the unique way of handling mocking for testing porpuses, learn how to work with them in this article.<\/description><link>https:\/\/matiasglessi.com\/posts\/first-post<\/link><pubDate>Wed, 23 Feb 2022 21:21:00 -0300<\/pubDate><content:encoded><![CDATA[<h1>Test Doubles in Swift<\/h1><p>My first post's text.<\/p>]]><\/content:encoded><\/item><item><guid isPermaLink=\"true\">https:\/\/matiasglessi.com\/posts\/first-post2<\/guid><title>Mock, Stub, Spy, and other Test Doubles<\/title><description>Test doubles are the unique way of handling mocking for testing porpuses, learn how to work with them in this article.<\/description><link>https:\/\/matiasglessi.com\/posts\/first-post2<\/link><pubDate>Wed, 23 Feb 2022 21:21:00 -0300<\/pubDate><content:encoded><![CDATA[<h1>Mock, Stub, Spy, and other Test Doubles<\/h1><p>Many times we find ourselves looking for a way to simulate objects and\/or dependencies of our classes or modules when testing. That's where mock test objects come in, which in popular jargon are often called “Mocks”. Although this is not incorrect since they are elements that “mimic” something else, the correct term is Test Doubles. <a href=\"http:\/\/www.amazon.com\/xUnit-Test-Patterns-Refactoring-Code\/dp\/0131495054\">In the words of Gerard Meszaros<\/a>, Test Double is a generic term for any case where you replace a production object for testing purposes.<\/p><p>In this <a href=\"http:\/\/xunitpatterns.com\/Test%20Double.html\">article<\/a>, Gerard Meszaros introduced five types of Test Doubles: Dummy, Fake, Stub, Spy, Mock. We will see each one of them, and when its application is convenient.<\/p><p>To do this, we will follow this simple example:<\/p><pre><code class=\"language-swift\">typealias Days = Int\nlet REGISTERED_USER = \"matiasglessi@gmail.com\"\n\nprotocol EmailService {\n    func sendEmail(to mail: String, subject: String)\n}\n\nprotocol DatabaseService {\n    func getDaysToExpiration() -&gt; Days\n}\n\nclass NotificationService {\n    private let emailService: EmailService\n    private let databaseService: DatabaseService\n    \n    init(emailService: EmailService, databaseService: DatabaseService) {\n        self.emailService = emailService\n        self.databaseService = databaseService\n    }\n    \n    func validateStatus() {\n        let days = databaseService.getDaysToExpiration()\n        \n        if isAboutToExpire(days){\n            emailService.sendEmail(to: REGISTERED_USER,\n                                   subject: \"Your service is close to expiration.\")\n        }\n    }\n    \n    private func isAboutToExpire(_ days: Days) -&gt; Bool {\n        days &lt; 10\n    }\n}\n<\/code><\/pre><p>This code shows the logic of a service called NotificationService, which is fed through dependency injection with two other services: EmailService and DatabaseService. Basically, the validateStatus() method evaluates how many days are left for the service to expire (using DatabaseService) and if it is less than 10, an email is sent to the user (using EmailService).<\/p><h3>Dummy<\/h3><p>It is the simplest of all. They are objects that are passed from one place to another but are not used. They usually exist for the sole purpose of completing parameters or satisfying dependencies.<\/p><p>In this case, we can assume the need to validate the correct initialization of the NotificationService service. We could create dummy implementations of its dependencies as follows:<\/p><pre><code class=\"language-swift\">class DummyEmailService: EmailService {\n    func sendEmail(to mail: String, subject: String) {\n        fatalError(\"This service implementation should not be used.\")\n    }\n}\n\nclass DummyDatabaseService: DatabaseService {\n    func getDaysToExpiration() -&gt; Days {\n        fatalError(\"This service implementation should not be used.\")\n    }\n}\n<\/code><\/pre><p>As you can see, using these implementations would cause the application to crash. The use of some kind of exception or error generator (NullPointerException, fatalError(), etc) is a good practice to avoid its use in production code.<\/p><pre><code class=\"language-swift\">class NotificationServiceTests_DummyExample: XCTest {\n \n    func test_onNotificationServiceInit_NotificationServiceIsNotNil() {\n        let emailService = DummyEmailService()\n        let databaseService = DummyDatabaseService()\n        \n        let notificationService = NotificationService(\n            emailService: emailService,\n            databaseService: databaseService\n        )\n        \n        XCTAssertNotNil(notificationService)\n    }\n}\n<\/code><\/pre><p>In order to test a function of the NotificationService service, the corresponding Test Double must exist for EmailService and for DatabaseService. Since they have no use in the test<em>onNotificationServiceInit<\/em>NotificationServiceIsNotNil() test case, it's okay to implement it as Dummy.<\/p><h3>Stub<\/h3><p>Stubs are objects that provide predefined responses. They are usually used to define a specific type of response expected from the object\/dependency that is being simulated, in order to guide the test in a certain direction. Following the same example, suppose we need to validate different responses from the database. We could create Stubs in the following way:<\/p><pre><code class=\"language-swift\">class CloseToExpirationDatabaseServiceStub: DatabaseService {\n    func getDaysToExpiration() -&gt; Days {\n        5\n    }\n}\n\nclass NotCloseToExpirationDatabaseServiceStub: DatabaseService {\n    func getDaysToExpiration() -&gt; Days {\n        135\n    }\n}\n<\/code><\/pre><p>In this case, we create two different Stubs with the possible situations that can occur. Thus, using the first, we could validate what should happen when the number of days is less than 10, and with the second, the case when the result is greater. Instead of performing a validation, a login, or a search in a real database, (to give some examples) we return what is useful for that test case: a specific boolean, a value, a valid object or invalid, etc.<\/p><p>Performing the actual operation, by calling the actual services, is possible, but it takes time and requires configuration. If there is a bug in the called service, the tests fail for the wrong reasons. And after all, it is an unnecessary coupling.<\/p><h3>Spy<\/h3><p>Spy objects are those that, in addition to being Stubs (that is, they return the desired predefined information) also record data on how they were called in some way.<\/p><p>The stored information can be given through variables that store boolean information if the call was made or not, an integer value about the number of times said call was made, or any type of argument that you are interested in saving.<\/p><p>In the case of EmailService, we can generate a Spy as follows:<\/p><pre><code class=\"language-swift\">class SpyEmailService: EmailService {\n    \n    var emailServiceWasCalled: Bool = false\n    \n    func sendEmail(to mail: String, subject: String) {\n        emailServiceWasCalled = true\n    }\n}\n<\/code><\/pre><p>This Test Double will log the call to the sendEmail(mail:subject:) method via the emailServiceWasCalled boolean property.<\/p><p>Thus, we can use the Spy in the following context:<\/p><pre><code class=\"language-swift\">class NotificationServiceTests_SpyExample: XCTest {\n \n    func test_onNotificationServiceStatusValidationCloseToExpiration_EmailServiceIsCalled() {\n        let emailService = SpyEmailService()\n        let databaseService = CloseToExpirationDatabaseServiceStub()\n        \n        let notificationService = NotificationService(\n            emailService: emailService,\n            databaseService: databaseService\n        )\n        \n        notificationService.validateStatus()\n        \n        XCTAssertTrue(emailService.emailServiceWasCalled)\n    }\n}\n<\/code><\/pre><p>The test<em>onNotificationServiceStatusValidationCloseToExpiration<\/em>EmailServiceIsCalled() test creates the <a href=\"https:\/\/en.wikipedia.org\/wiki\/System_under_test\">SUT<\/a> from the Stub we saw earlier for the DatabaseService and a Spy for the EmailService, which will save the information on whether the service was called or not. Since the Stub returns a default value less than 10, when calling validateStatus() the mailing service should have been called, exactly what is evaluated in the following XCTAssert statement.<\/p><p>But beware! The more internal information we are storing about how our module works, the greater the risk of coupling to the system implementation. And that can lead to brittle tests (that fail for reasons unrelated to the test).<\/p><h3>Mock<\/h3><p>Mocks are objects that record the calls they receive and analyze the behavior. When we are in the verification part of the test, we can check that all the expected actions were carried out.<\/p><p>They know what is being tested, which is why they are said to assess behavior. They are Spy type objects since they spy on the behavior of the module being tested. And it is the mock itself that knows what behavior to expect. In the example, we can perform a Mock by moving the verification to the Test Double's own code:<\/p><pre><code class=\"language-swift\">class EmailServiceMock: EmailService {\n    \n    private var emailServiceWasCalled: Bool = false\n    private var emailsSentCount = 0\n    \n    func sendEmail(to mail: String, subject: String) {\n        emailServiceWasCalled = true\n        emailsSentCount += 1\n    }\n    \n    func verify() -&gt; Bool {\n        emailServiceWasCalled &amp;&amp; emailsSentCount == 1\n    }\n}\n<\/code><\/pre><p>The EmailServiceMock acts as a Spy, saving information regarding the call made. This information is then validated in the mock itself, in its verify() method, where it evaluates that the behavior has been as expected: in this case, that the service was actually called and that a single email was sent. This would be the evaluation, analyzing the result of the verify() method in the EmailServiceMock itself:<\/p><pre><code class=\"language-swift\">    func test_onNotificationServiceStatusValidationCloseToExpiration_EmailServiceIsCalledCorrectly() {\n        let emailService = EmailServiceMock()\n        let databaseService = CloseToExpirationDatabaseServiceStub()\n        \n        let notificationService = NotificationService(\n            emailService: emailService,\n            databaseService: databaseService\n        )\n        \n        notificationService.validateStatus()\n        \n        XCTAssertTrue(emailService.verify())\n    }\n}\n<\/code><\/pre><p>We use mocks when we don't want to call production code or when there is no easy way to verify that the system actually did something. The only thing we can do for these cases is to verify that the service was called and works (and what that implies, which may be making calls to other mocked services).<\/p><h3>Fake<\/h3><p>Fake objects are those that have working implementations, but usually have some shortcut or structure that makes them unfeasible for production use. Unlike any other type of Test Double, they have real business behavior, which can be complex to manage (even requiring their own tests) and dangerous, since they can easily be used in production.<\/p><p>In this case, we can create a Fake as follows:<\/p><pre><code class=\"language-swift\">class FakeDatabaseService: DatabaseService {\n    \n    var daysToExpiration: Int = 0\n    \n    func getDaysToExpiration() -&gt; Days {\n        return daysToExpiration\n    }\n    \n    func updateDaysToExpiration(_ days: Days) {\n        daysToExpiration = days\n    }\n}\n<\/code><\/pre><p>This FakeDatabaseService will be an implementation of the functional DatabaseService service, since it is using a variable in memory to store the information obtained. As Martin Fowler mentions in InMemoryTestDatabase, Fake databases serve as a replacement for database access in test cases. Beyond the fact that there may be cases where an in-memory database is actually used, its use as a Test Double to test dependencies results in a fast and efficient testing practice, since long and slow setups are avoided, as usually required by databases configurations.<\/p><p>There are several types of Test Doubles with different intentions. Confusing and mixing your implementations can influence test design, and increase its brittleness. That is why it is of great importance to understand the types that exist and when to use each one.<\/p><h4>References<\/h4><ul><li><a href=\"https:\/\/martinfowler.com\/bliki\/TestDouble.html\">martinfowler.com: Test Double<\/a><\/li><li><a href=\"https:\/\/martinfowler.com\/articles\/mocksArentStubs.html\">martinfowler.com: Mocks Aren't Stubs<\/a><\/li><li><a href=\"https:\/\/martinfowler.com\/bliki\/InMemoryTestDatabase.html\">martinfowler.com: InMemoryTestDatabase<\/a><\/li><li><a href=\"http:\/\/www.amazon.com\/xUnit-Test-Patterns-Refactoring-Code\/dp\/0131495054\">amazon.com: xUnit Test Patterns Book<\/a><\/li><li><a href=\"http:\/\/xunitpatterns.com\/Test%20Double.html\">xunitpatterns.com: Test Double<\/a><\/li><li><a href=\"https:\/\/blog.cleancoder.com\/uncle-bob\/2014\/05\/14\/TheLittleMocker.html\">cleancoder.com: The Little Mocker<\/a><\/li><\/ul><hr><p>Do you see something strange or wrong in this article? It's hosted on <a href=\"\">Github<\/a>, you can open a Pull Request for discussion and request an edit. You can also contact me directly <a href=\"mailto:matiasglessi@gmail.com\">here<\/a>.<\/p>]]><\/content:encoded><\/item><\/channel><\/rss>"}