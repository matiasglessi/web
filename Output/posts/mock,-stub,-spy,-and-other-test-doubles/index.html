<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Matias Glessi | iOS Engineer"/><link rel="canonical" href="https://matiasglessi.com/posts/mock,-stub,-spy,-and-other-test-doubles"/><meta name="twitter:url" content="https://matiasglessi.com/posts/mock,-stub,-spy,-and-other-test-doubles"/><meta name="og:url" content="https://matiasglessi.com/posts/mock,-stub,-spy,-and-other-test-doubles"/><title>Mock, Stub, Spy, and other Test Doubles | Matias Glessi | iOS Engineer</title><meta name="twitter:title" content="Mock, Stub, Spy, and other Test Doubles | Matias Glessi | iOS Engineer"/><meta name="og:title" content="Mock, Stub, Spy, and other Test Doubles | Matias Glessi | iOS Engineer"/><meta name="description" content="Brief review of the Mocking technique for testing, and the structures that can be used according to the need of the moment."/><meta name="twitter:description" content="Brief review of the Mocking technique for testing, and the structures that can be used according to the need of the moment."/><meta name="og:description" content="Brief review of the Mocking technique for testing, and the structures that can be used according to the need of the moment."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Matias Glessi | iOS Engineer"/></head><body><div class="wrapper container"><div class="wrapper mobile-navbar"><h1>Mat√≠as Glessi üë®‚Äçüíª</h1><ul class="mediaLinks-list"><li><a href="http://google.com.ar" class="current">Blog</a></li><li><a href="http://google.com.ar" class="mediaLink">About</a></li></ul></div><div class="wrapper sidebar"><img src="https://avatars0.githubusercontent.com/u/9439622?s=460&v=4" alt="Matias Glessi's profile picture"/><h1>Mat√≠as Glessi</h1><h2>iOS Engineer</h2><div class="wrapper"><ul class="mediaLinks-list"><li><div class="wrapper location"><a href="https://es.wikipedia.org/wiki/La_Plata">La Plata, Argentina  üá¶üá∑</a></div></li><li><div class="wrapper mail"><a href="mailto:matiasglessi@gmail.com">matiasglessi@gmail.com</a></div></li><li><div class="wrapper linkedin"><a href="https://www.linkedin.com/in/matias-alejandro-glessi/">LinkedIn</a></div></li><li><div class="wrapper github"><a href="https://github.com/matiasglessi">GitHub</a></div></li></ul></div></div><div class="wrapper right-content"><div class="wrapper navbar"><ul class="mediaLinks-list"><li><a href="http://google.com.ar" class="current">BLOG</a></li><li><a href="http://google.com.ar" class="mediaLink">ABOUT</a></li></ul></div><div class="wrapper"><article><div class="wrapper post-header"><h4>FEBRUARY 23, 2022</h4><h1><a href="/posts/mock,-stub,-spy,-and-other-test-doubles">Mock, Stub, Spy, and other Test Doubles</a></h1><ul class="post-header-links"><li><label class="reading-time">Reading Time: 7 minutes</label></li><li><label class="no-link-label">N/A ‚Äî no external link</label></li></ul></div><div class="content"><p>Many times we find ourselves looking for a way to simulate objects and/or dependencies of our classes or modules when testing. That's where mock test objects come in, which in popular jargon are often called ‚ÄúMocks‚Äù. Although this is not incorrect since they are elements that ‚Äúmimic‚Äù something else, the correct term is Test Doubles. <a href="http://www.amazon.com/xUnit-Test-Patterns-Refactoring-Code/dp/0131495054">In the words of Gerard Meszaros</a>, Test Double is a generic term for any case where you replace a production object for testing purposes.</p><p>In this <a href="http://xunitpatterns.com/Test%20Double.html">article</a>, Gerard Meszaros introduced five types of Test Doubles: Dummy, Fake, Stub, Spy, Mock. We will see each one of them, and when its application is convenient.</p><p>To do this, we will follow this simple example:</p><pre><code><span class="keyword">typealias</span> Days = <span class="type">Int</span>
<span class="keyword">let</span> <span class="type">REGISTERED_USER</span> = <span class="string">"matiasglessi@gmail.com"</span>

<span class="keyword">protocol</span> EmailService {
    <span class="keyword">func</span> sendEmail(to mail: <span class="type">String</span>, subject: <span class="type">String</span>)
}

<span class="keyword">protocol</span> DatabaseService {
    <span class="keyword">func</span> getDaysToExpiration() -&gt; <span class="type">Days</span>
}

<span class="keyword">class</span> NotificationService {
    <span class="keyword">private let</span> emailService: <span class="type">EmailService</span>
    <span class="keyword">private let</span> databaseService: <span class="type">DatabaseService</span>
    
    <span class="keyword">init</span>(emailService: <span class="type">EmailService</span>, databaseService: <span class="type">DatabaseService</span>) {
        <span class="keyword">self</span>.<span class="property">emailService</span> = emailService
        <span class="keyword">self</span>.<span class="property">databaseService</span> = databaseService
    }
    
    <span class="keyword">func</span> validateStatus() {
        <span class="keyword">let</span> days = databaseService.<span class="call">getDaysToExpiration</span>()
        
        <span class="keyword">if</span> <span class="call">isAboutToExpire</span>(days){
            emailService.<span class="call">sendEmail</span>(to: <span class="type">REGISTERED_USER</span>,
                                   subject: <span class="string">"Your service is close to expiration."</span>)
        }
    }
    
    <span class="keyword">private func</span> isAboutToExpire(<span class="keyword">_</span> days: <span class="type">Days</span>) -&gt; <span class="type">Bool</span> {
        days &lt; <span class="number">10</span>
    }
}
</code></pre><p>This code shows the logic of a service called NotificationService, which is fed through dependency injection with two other services: EmailService and DatabaseService. Basically, the validateStatus() method evaluates how many days are left for the service to expire (using DatabaseService) and if it is less than 10, an email is sent to the user (using EmailService).</p><h3>Dummy</h3><p>It is the simplest of all. They are objects that are passed from one place to another but are not used. They usually exist for the sole purpose of completing parameters or satisfying dependencies.</p><p>In this case, we can assume the need to validate the correct initialization of the NotificationService service. We could create dummy implementations of its dependencies as follows:</p><pre><code><span class="keyword">class</span> DummyEmailService: <span class="type">EmailService</span> {
    <span class="keyword">func</span> sendEmail(to mail: <span class="type">String</span>, subject: <span class="type">String</span>) {
        <span class="call">fatalError</span>(<span class="string">"This service implementation should not be used."</span>)
    }
}

<span class="keyword">class</span> DummyDatabaseService: <span class="type">DatabaseService</span> {
    <span class="keyword">func</span> getDaysToExpiration() -&gt; <span class="type">Days</span> {
        <span class="call">fatalError</span>(<span class="string">"This service implementation should not be used."</span>)
    }
}
</code></pre><p>As you can see, using these implementations would cause the application to crash. The use of some kind of exception or error generator (NullPointerException, fatalError(), etc) is a good practice to avoid its use in production code.</p><pre><code><span class="keyword">class</span> NotificationServiceTests_DummyExample: <span class="type">XCTest</span> {
 
    <span class="keyword">func</span> test_onNotificationServiceInit_NotificationServiceIsNotNil() {
        <span class="keyword">let</span> emailService = <span class="type">DummyEmailService</span>()
        <span class="keyword">let</span> databaseService = <span class="type">DummyDatabaseService</span>()
        
        <span class="keyword">let</span> notificationService = <span class="type">NotificationService</span>(
            emailService: emailService,
            databaseService: databaseService
        )
        
        <span class="call">XCTAssertNotNil</span>(notificationService)
    }
}
</code></pre><p>In order to test a function of the NotificationService service, the corresponding Test Double must exist for EmailService and for DatabaseService. Since they have no use in the test<em>onNotificationServiceInit</em>NotificationServiceIsNotNil() test case, it's okay to implement it as Dummy.</p><h3>Stub</h3><p>Stubs are objects that provide predefined responses. They are usually used to define a specific type of response expected from the object/dependency that is being simulated, in order to guide the test in a certain direction. Following the same example, suppose we need to validate different responses from the database. We could create Stubs in the following way:</p><pre><code><span class="keyword">class</span> CloseToExpirationDatabaseServiceStub: <span class="type">DatabaseService</span> {
    <span class="keyword">func</span> getDaysToExpiration() -&gt; <span class="type">Days</span> {
        <span class="number">5</span>
    }
}

<span class="keyword">class</span> NotCloseToExpirationDatabaseServiceStub: <span class="type">DatabaseService</span> {
    <span class="keyword">func</span> getDaysToExpiration() -&gt; <span class="type">Days</span> {
        <span class="number">135</span>
    }
}
</code></pre><p>In this case, we create two different Stubs with the possible situations that can occur. Thus, using the first, we could validate what should happen when the number of days is less than 10, and with the second, the case when the result is greater. Instead of performing a validation, a login, or a search in a real database, (to give some examples) we return what is useful for that test case: a specific boolean, a value, a valid object or invalid, etc.</p><p>Performing the actual operation, by calling the actual services, is possible, but it takes time and requires configuration. If there is a bug in the called service, the tests fail for the wrong reasons. And after all, it is an unnecessary coupling.</p><h3>Spy</h3><p>Spy objects are those that, in addition to being Stubs (that is, they return the desired predefined information) also record data on how they were called in some way.</p><p>The stored information can be given through variables that store boolean information if the call was made or not, an integer value about the number of times said call was made, or any type of argument that you are interested in saving.</p><p>In the case of EmailService, we can generate a Spy as follows:</p><pre><code><span class="keyword">class</span> SpyEmailService: <span class="type">EmailService</span> {
    
    <span class="keyword">var</span> emailServiceWasCalled: <span class="type">Bool</span> = <span class="keyword">false
    
    func</span> sendEmail(to mail: <span class="type">String</span>, subject: <span class="type">String</span>) {
        emailServiceWasCalled = <span class="keyword">true</span>
    }
}
</code></pre><p>This Test Double will log the call to the sendEmail(mail:subject:) method via the emailServiceWasCalled boolean property.</p><p>Thus, we can use the Spy in the following context:</p><pre><code><span class="keyword">class</span> NotificationServiceTests_SpyExample: <span class="type">XCTest</span> {
 
    <span class="keyword">func</span> test_onNotificationServiceStatusValidationCloseToExpiration_EmailServiceIsCalled() {
        <span class="keyword">let</span> emailService = <span class="type">SpyEmailService</span>()
        <span class="keyword">let</span> databaseService = <span class="type">CloseToExpirationDatabaseServiceStub</span>()
        
        <span class="keyword">let</span> notificationService = <span class="type">NotificationService</span>(
            emailService: emailService,
            databaseService: databaseService
        )
        
        notificationService.<span class="call">validateStatus</span>()
        
        <span class="call">XCTAssertTrue</span>(emailService.<span class="property">emailServiceWasCalled</span>)
    }
}
</code></pre><p>The test<em>onNotificationServiceStatusValidationCloseToExpiration</em>EmailServiceIsCalled() test creates the <a href="https://en.wikipedia.org/wiki/System_under_test">SUT</a> from the Stub we saw earlier for the DatabaseService and a Spy for the EmailService, which will save the information on whether the service was called or not. Since the Stub returns a default value less than 10, when calling validateStatus() the mailing service should have been called, exactly what is evaluated in the following XCTAssert statement.</p><p>But beware! The more internal information we are storing about how our module works, the greater the risk of coupling to the system implementation. And that can lead to brittle tests (that fail for reasons unrelated to the test).</p><h3>Mock</h3><p>Mocks are objects that record the calls they receive and analyze the behavior. When we are in the verification part of the test, we can check that all the expected actions were carried out.</p><p>They know what is being tested, which is why they are said to assess behavior. They are Spy type objects since they spy on the behavior of the module being tested. And it is the mock itself that knows what behavior to expect. In the example, we can perform a Mock by moving the verification to the Test Double's own code:</p><pre><code><span class="keyword">class</span> EmailServiceMock: <span class="type">EmailService</span> {
    
    <span class="keyword">private var</span> emailServiceWasCalled: <span class="type">Bool</span> = <span class="keyword">false
    private var</span> emailsSentCount = <span class="number">0</span>
    
    <span class="keyword">func</span> sendEmail(to mail: <span class="type">String</span>, subject: <span class="type">String</span>) {
        emailServiceWasCalled = <span class="keyword">true</span>
        emailsSentCount += <span class="number">1</span>
    }
    
    <span class="keyword">func</span> verify() -&gt; <span class="type">Bool</span> {
        emailServiceWasCalled &amp;&amp; emailsSentCount == <span class="number">1</span>
    }
}
</code></pre><p>The EmailServiceMock acts as a Spy, saving information regarding the call made. This information is then validated in the mock itself, in its verify() method, where it evaluates that the behavior has been as expected: in this case, that the service was actually called and that a single email was sent. This would be the evaluation, analyzing the result of the verify() method in the EmailServiceMock itself:</p><pre><code>     <span class="keyword">func</span> test_onNotificationServiceStatusValidationCloseToExpiration_EmailServiceIsCalledCorrectly() {
        <span class="keyword">let</span> emailService = <span class="type">EmailServiceMock</span>()
        <span class="keyword">let</span> databaseService = <span class="type">CloseToExpirationDatabaseServiceStub</span>()
        
        <span class="keyword">let</span> notificationService = <span class="type">NotificationService</span>(
            emailService: emailService,
            databaseService: databaseService
        )
        
        notificationService.<span class="call">validateStatus</span>()
        
        <span class="call">XCTAssertTrue</span>(emailService.<span class="call">verify</span>())
    }
}
</code></pre><p>We use mocks when we don't want to call production code or when there is no easy way to verify that the system actually did something. The only thing we can do for these cases is to verify that the service was called and works (and what that implies, which may be making calls to other mocked services).</p><h3>Fake</h3><p>Fake objects are those that have working implementations, but usually have some shortcut or structure that makes them unfeasible for production use. Unlike any other type of Test Double, they have real business behavior, which can be complex to manage (even requiring their own tests) and dangerous, since they can easily be used in production.</p><p>In this case, we can create a Fake as follows:</p><pre><code><span class="keyword">class</span> FakeDatabaseService: <span class="type">DatabaseService</span> {
    
    <span class="keyword">var</span> daysToExpiration: <span class="type">Int</span> = <span class="number">0</span>
    
    <span class="keyword">func</span> getDaysToExpiration() -&gt; <span class="type">Days</span> {
        <span class="keyword">return</span> daysToExpiration
    }
    
    <span class="keyword">func</span> updateDaysToExpiration(<span class="keyword">_</span> days: <span class="type">Days</span>) {
        daysToExpiration = days
    }
}
</code></pre><p>This FakeDatabaseService will be an implementation of the functional DatabaseService service, since it is using a variable in memory to store the information obtained. As Martin Fowler mentions in InMemoryTestDatabase, Fake databases serve as a replacement for database access in test cases. Beyond the fact that there may be cases where an in-memory database is actually used, its use as a Test Double to test dependencies results in a fast and efficient testing practice, since long and slow setups are avoided, as usually required by databases configurations.</p><p>There are several types of Test Doubles with different intentions. Confusing and mixing your implementations can influence test design, and increase its brittleness. That is why it is of great importance to understand the types that exist and when to use each one.</p><h4>References</h4><ul><li><a href="https://martinfowler.com/bliki/TestDouble.html">martinfowler.com: Test Double</a></li><li><a href="https://martinfowler.com/articles/mocksArentStubs.html">martinfowler.com: Mocks Aren't Stubs</a></li><li><a href="https://martinfowler.com/bliki/InMemoryTestDatabase.html">martinfowler.com: InMemoryTestDatabase</a></li><li><a href="http://www.amazon.com/xUnit-Test-Patterns-Refactoring-Code/dp/0131495054">amazon.com: xUnit Test Patterns Book</a></li><li><a href="http://xunitpatterns.com/Test%20Double.html">xunitpatterns.com: Test Double</a></li><li><a href="https://blog.cleancoder.com/uncle-bob/2014/05/14/TheLittleMocker.html">cleancoder.com: The Little Mocker</a></li></ul><hr><p>Do you see something strange or wrong in this article? It's hosted on <a href="">Github</a>, you can open a Pull Request for discussion and request an edit. You can also contact me directly <a href="mailto:matiasglessi@gmail.com">here</a>.</p></div></article></div><footer><p>Generated in Swift ‚ù§Ô∏è, using <a href="https://github.com/johnsundell/publish">Publish</a></p><p>¬© Copyright 2022</p></footer></div></div></body></html>