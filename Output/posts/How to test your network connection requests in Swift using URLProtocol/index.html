<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Matias Glessi | iOS Engineer"/><link rel="canonical" href="https://matiasglessi.com/posts/How%20to%20test%20your%20network%20connection%20requests%20in%20Swift%20using%20URLProtocol"/><meta name="twitter:url" content="https://matiasglessi.com/posts/How%20to%20test%20your%20network%20connection%20requests%20in%20Swift%20using%20URLProtocol"/><meta name="og:url" content="https://matiasglessi.com/posts/How%20to%20test%20your%20network%20connection%20requests%20in%20Swift%20using%20URLProtocol"/><title>How to test your network connection requests in Swift using URLProtocol | Matias Glessi | iOS Engineer</title><meta name="twitter:title" content="How to test your network connection requests in Swift using URLProtocol | Matias Glessi | iOS Engineer"/><meta name="og:title" content="How to test your network connection requests in Swift using URLProtocol | Matias Glessi | iOS Engineer"/><meta name="description" content="A reliable and decoupled approach to testing network requests in Swift."/><meta name="twitter:description" content="A reliable and decoupled approach to testing network requests in Swift."/><meta name="og:description" content="A reliable and decoupled approach to testing network requests in Swift."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Matias Glessi | iOS Engineer"/></head><body><div class="wrapper container"><div class="wrapper mobile-navbar"><h1>Matías Glessi</h1><ul class="mediaLinks-list"><li><a href="http://localhost:8000/" class="current">Blog</a></li><li><a href="http://localhost:8000/about/" class="mediaLink">About</a></li></ul></div><div class="wrapper sidebar"><img src="/../../images/avatar.jpg" alt="Matias Glessi's profile picture"/><h1>Matías Glessi</h1><h2>iOS Engineer</h2><div class="wrapper"><ul class="mediaLinks-list"><li><div class="wrapper location"><a href="https://es.wikipedia.org/wiki/La_Plata">La Plata, Argentina  🇦🇷</a></div></li><li><div class="wrapper mail"><a href="mailto:matiasglessi@gmail.com">matiasglessi@gmail.com</a></div></li><li><div class="wrapper linkedin"><a href="https://www.linkedin.com/in/matias-alejandro-glessi/">LinkedIn</a></div></li><li><div class="wrapper github"><a href="https://github.com/matiasglessi">GitHub</a></div></li></ul></div></div><div class="wrapper right-content"><div class="wrapper navbar"><ul class="mediaLinks-list"><li><a href="http://localhost:8000/" class="current">BLOG</a></li><li><a href="http://localhost:8000/about/" class="mediaLink">ABOUT</a></li></ul></div><div class="wrapper"><article><div class="wrapper post-header"><h4>JULY 23, 2022</h4><h1><a href="/posts/How to test your network connection requests in Swift using URLProtocol">How to test your network connection requests in Swift using URLProtocol</a></h1><ul class="post-header-links"><li><label class="reading-time">Reading Time: 14 minutes</label></li><li><label class="no-link-label">N/A — no external link</label></li></ul><div class="wrapper header-section-breaker"><div></div></div></div><div class="content"><p>In this post we will see how to test network requests using the perhaps not so well-known <strong><em>URL Loading System</em></strong>, which intercepts requests made to the server. To address our problem, we'll put some example code, assuming we have an implementation of this style in our productive code:</p><pre><code><span class="keyword">enum</span> HTTPResult {
    <span class="keyword">case</span> success(<span class="type">Data</span>, <span class="type">HTTPURLResponse</span>)
    <span class="keyword">case</span> failure(<span class="type">Error</span>)
}

<span class="keyword">protocol</span> HTTPClient {
    <span class="keyword">func</span> get(from <span class="type">URL</span>: <span class="type">URL</span>, completion: <span class="keyword">@escaping</span> (<span class="type">HTTPResult</span>) -&gt; <span class="type">Void</span>)


<span class="keyword">class</span> URLSessionHTTPClient: <span class="type">HTTPClient</span> {
    <span class="keyword">private let</span> session: <span class="type">URLSession</span>

    <span class="keyword">init</span>(session: <span class="type">URLSession</span> = .<span class="dotAccess">shared</span>) {
        <span class="keyword">self</span>.<span class="property">session</span> = session
    }

    <span class="keyword">func</span> get(from url: <span class="type">URL</span>, completion: <span class="keyword">@escaping</span> (<span class="type">HTTPResult</span>) -&gt; <span class="type">Void</span>) {
        session.<span class="call">dataTask</span>(with: url) { <span class="keyword">_</span>, <span class="keyword">_</span>, error <span class="keyword">in
            if let</span> error = error {
                <span class="call">completion</span>(.<span class="call">failure</span>(error))
            }
        }.<span class="call">resume</span>()
    }
}
</code></pre><p>Here, we see a simple example of an interface to an HTTP client, called <em>HTTPClient</em>. This is made up of a single method that receives a URL and returns a result, which can be a success (with its corresponding <em>Data</em> and <em>Response</em>) or a failure (with an <em>Error</em>).</p><p>At the same time, it has a <em>URLSessionHTTPClient</em> implementation, which is responsible for communicating with the network. In our case we use <em>URLSession</em>, Apple's framework for network requests. As the focus is on understanding how to test this component of the system, we will leave an implementation already done, although this could be created from the test decisions, following <em>Test Driven Development (TDD)</em>.</p><p>First, we will see some alternative strategies to test implementation, which, although valid, have some disadvantages to consider, which will guide this post.</p><h3>Test real connections</h3><p>One way to resolve this could be to test the connection for real. That is, the request is made to the backend, the response is obtained and it is evaluated if it is correct. Although it is a valid option, we easily find several reasons why this strategy can be problematic: What if the backend is not developed yet? How do we handle the multiple causes for which a connection can fail? How to increase the duration of the test if the connection is too slow? As we mentioned, although it is valid as a strategy, it is probably better to test the component in isolation.</p><p>Testing the service in an end-to-end way would be more useful if it took several components and how they are integrated.</p><h3>Mock with Subclasses</h3><p>Since our implementation will use the <a href="https://developer.apple.com/documentation/foundation/urlsession "Apple URLSession"">Apple URLSession</a> framework to make connections to the server, one strategy would be to mock it, implementing a subclass of it that can spy on or capture the information needed to validate our tests. For example, we could add flags to check that the methods were called, or even save certain values such as URLs sent, or even the <a href="https://developer.apple.com/documentation/foundation/urlsessiondatatask "URLSessionDataTask"">URLSessionDataTask</a> used (mocking these too), and validate that they are correct.</p><p>The problem with this strategy is that since it is a subclass of an Apple framework, there are many methods that we are not even aware of, which we should implement if we want to have full control of the class. Otherwise, our tests may end up using the methods of the parent class, which is dangerous since we would not be sure how it really works (or if network requests are actually made in this specific case). In each release even Apple can add new methods or update the old ones, changing how they work and causing our tests to fail.</p><h3>Mock with Protocols</h3><p>A third option to address the issue is to create protocols that mimic the interfaces we are interested in mocking. For example we could create something like this:</p><pre><code><span class="keyword">protocol</span> HTTPSession {
    <span class="keyword">func</span> dataTask(
        with url: <span class="type">URL</span>,
        completionHandler: <span class="keyword">@escaping</span> (<span class="type">Data</span>?, <span class="type">URLResponse</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>)
    -&gt; <span class="type">HTTPSessionTask</span>
}

<span class="keyword">protocol</span> HTTPSessionTask {
    <span class="keyword">func</span> resume()
}
</code></pre><p>Thus, we would have a protocol very similar to <em>URLSession</em> (and another similar to <em>URLSessionDataTask</em>) that would only have the method that we are interested in mocking. In the test, our <em>SUT</em> will interact with the created protocol instead of the <em>URLSession</em>. This allows us to avoid assumptions about unknown methods and secret Apple implementations of how things work, in this case regarding the <em>URLSession</em> API. It also saves us the need to update these tests in the future in case Apple decides to update their methods since we only implement methods that we care about.</p><p>While this is another valid strategy, another problem makes this not the best solution: since we are mimicking the <em>URLSession</em> methods, there is a strong coupling with this API. Also, we're adding productive code just to satisfy our tests, which is definitely a wake-up call.</p><h2>Using the URL Loading System</h2><p>According to Apple's definition, the <a href="https://developer.apple.com/documentation/foundation/url_loading_system "URL Loading System"">URL Loading System</a> allows you to interact with URLs and communicate with servers using standard protocols (such as HTTP/HTTPS, for example) or with your <strong>own protocols that you can create</strong>.</p><img src="/images/posts/urlloadingsystem/URLLoadingSystem.png" alt="URL Loading System diagram" width="450"/><p>How does it work? Basically for every time a request is made, what happens behind the scenes is that there is a system (the URL Loading System) that processes it. As part of it, there is a type called <em>URLProtocol</em>, which is an <strong>abstract class</strong> that inherits from <em>NSObject</em>.</p><p>So if we create our own <em>URLProtocol</em> and register it, we can start intercepting URL Requests. What is it for? As in this case, we could evaluate the component using a particular protocol, implement some kind of Cache, track information for Analytics, or even evaluate the performance of the requests.</p><p>For this, we only have to implement the methods of the abstract class <em>URLProtocol</em>, which although it sounds strange, is a class. In this case, we will create a mock that implements this class and we will evaluate the validity of the tested requests, with the certainty that the requests are never made and no information is sent to any server, making the tests faster and more reliable.</p><h3>Creating our own protocol</h3><p>Since the URL Loading System processes requests through different protocols, we will create our own. This subclass of <em>URLProtocol</em> will have the objective of intercepting the information that is transmitted and validating it.</p><pre><code>     <span class="keyword">private class</span> URLProtocolStub: <span class="type">URLProtocol</span> { ... }
</code></pre><p>Since we want to intercept the information from a <em>URLRequest</em>, we could store this information in a structure within our <em>URLProtocolStub</em>. A dictionary could be a good option:</p><pre><code><span class="keyword">private static var</span> stubs = [<span class="type">URL</span>: <span class="type">Stub</span>]()

<span class="keyword">private struct</span> Stub {
    <span class="keyword">let</span> data: <span class="type">Data</span>?
    <span class="keyword">let</span> response: <span class="type">URLResponse</span>
    <span class="keyword">let</span> error: <span class="type">Error</span>?
}
</code></pre><p>Thus, when we are preparing our test case in the part of its preparation, we can save this information, and then perform the corresponding checks. Something like:</p><pre><code><span class="keyword">let</span> urlProtocol = <span class="type">URLProtocolStub</span>()
urlProtocol.<span class="call">stub</span>(url: url, data: <span class="keyword">nil</span>, response: <span class="keyword">nil</span>, error: error)
}
</code></pre><p>Where the <em>stub(url: data: response: error:)</em> method of <em>URLProtocolStub</em> will have a form similar to this:</p><pre><code><span class="keyword">func</span> stub(url: <span class="type">URL</span>, data: <span class="type">Data</span>?, response: <span class="type">URLResponse</span>?, error: <span class="type">Error</span>?) {
    stubs[url] = <span class="type">Stub</span>(data: data, response: response, error: error)
}
</code></pre><p>Now that we understand how we will store the information, we are ready to create a test case. We will test the error case, which is when the request has an error (error is not nil), and the client should return a <em>.failure(error)</em> result with the same error. It will be more or less like this:</p><pre><code><span class="keyword">func</span> test_onHTTPClientGetCall_failsOnRequestError() {
    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://any-url.com"</span>)!
    <span class="keyword">let</span> error = <span class="type">NSError</span>(domain: <span class="string">"any error"</span>, code: <span class="number">1</span>)
    <span class="keyword">let</span> urlProtocol = <span class="type">URLProtocolStub</span>()
    urlProtocol.<span class="call">stub</span>(url: url, data: <span class="keyword">nil</span>, response: <span class="keyword">nil</span>, error: error)

    <span class="keyword">let</span> sut = <span class="type">URLSessionHTTPClient</span>()

    <span class="keyword">let</span> exp = <span class="call">expectation</span>(description: <span class="string">"Wait for completion"</span>)

    sut.<span class="call">get</span>(from: url) { result <span class="keyword">in
        switch</span> result {
        <span class="keyword">case let</span> .<span class="call">failure</span>(receivedError <span class="keyword">as</span> <span class="type">NSError</span>):
            <span class="call">XCTAssertEqual</span>(receivedError, error)
        <span class="keyword">default</span>:
            <span class="type">XCTFail</span>(<span class="string">"Expected failure with error</span> \(error)<span class="string">, got</span> \(result) <span class="string">instead"</span>)
        }

        exp.<span class="call">fulfill</span>()
    }

    <span class="call">wait</span>(for: [exp], timeout: <span class="number">1.0</span>)
}
</code></pre><p>In the code above we see our first test case. In the preparation part of it, we will create a URL, a specific <em>Error</em>, and an instance of our <em>URLProtocolStub</em>, where we will add the corresponding stub for that request with an error (and its other elements as nil). We will then create an instance of the client and make an asynchronous call (with <a href="https://developer.apple.com/documentation/xctest/xctestcase/1500899-expectation/ "expectation""><em>expectation</em></a>).</p><p>Finally, we validate that the error received is the same as the one sent, through an <em>XCTAssertEqual(,)</em>, in the case of .<em>failure()</em>. In any other case, it is an unexpected result error.</p><p>If you're testing this in the IDE it's likely that nothing is compiling. This happens because we left the implementation of our Stub in the middle. We add that <em>URLProtocolStub</em> will be a subclass of <em>URLProtocol</em>, but we do not implement its requirements, which are mainly two. On the one hand, we must implement four methods of <em>URLProtocol</em>:</p><pre><code><span class="keyword">class func</span> canInit(with:<span class="type">URLRequest</span>) -&gt; <span class="type">Bool</span>
<span class="keyword">class func</span> canonicalRequest(for:<span class="type">URLRequest</span>)
<span class="keyword">func</span> startLoading()
<span class="keyword">func</span> stopLoading()
</code></pre><p>On the other hand, we must register our protocol, using the methods:</p><pre><code><span class="type">URLProtocol</span>.<span class="call">registerClass</span>(<span class="type">AnyClass</span>)
<span class="type">URLProtocol</span>.<span class="call">unregisterClass</span>(<span class="type">AnyClass</span>)
</code></pre><p>Don't worry, we'll look at both requirements in detail below.</p><h3>Meeting the Requirements: Overriding the URLProtocol methods</h3><p>Let's go through each of the methods that we need to override to meet the <em>URLProtocol</em> requirements. The first one will be <em>canInit(with: URLRequest) -&gt; Bool</em>. If we return true in this method, it means that we can process this request, and it will be our responsibility to complete the request with success or failure. We will be able to know if the urlRequest contains the necessary parts to do it.</p><p>How can we know if we can process this request?</p><pre><code><span class="keyword">override class func</span> canInit(with request: <span class="type">URLRequest</span>) -&gt; <span class="type">Bool</span> {
       <span class="keyword">guard let</span> url = request.<span class="property">url</span> <span class="keyword">else</span> { <span class="keyword">return false</span> }
       
       <span class="keyword">return</span> stubs[url] != <span class="keyword">nil</span>
}
</code></pre><p>Basically, as we are storing in a dictionary the information of that request (our Stub element) indexed through the corresponding URL, what will tell us whether or not it can process this request will be determined by whether or not we have the stub stored in the dictionary.</p><p>But, if we add that method in XCode we will have an error of the type:</p><pre><code><span class="type">Instance</span> member 'stubs' cannot be used on type '<span class="type">URLSessionHTTPClientTest</span>.<span class="type">URLProtocolStub</span>'
</code></pre><p>This is because <em>canInit</em> is called as a class method because we don't have an instance yet. The URL Loading System will instantiate the <em>URLProtocolStub</em> only if the request can be processed. Since we don't have an instance there are some modifications we need to make.</p><p>First, our stubs dictionary should be defined as static:</p><pre><code><span class="keyword">private static var</span> stubs = [<span class="type">URL</span>: <span class="type">Stub</span>]()
</code></pre><p>So should the "stub" method:</p><pre><code><span class="keyword">static func</span> stub(url: <span class="type">URL</span>, data: <span class="type">Data</span>?, response: <span class="type">URLResponse</span>?, error: <span class="type">Error</span>?) { ... }
</code></pre><p>Finally, in our test case, we will have to change the instantiation of the Stub, which would be like this, without creating any instance:</p><pre><code><span class="type">URLProtocolStub</span>.<span class="call">stub</span>(url: url, data: <span class="keyword">nil</span>, response: <span class="keyword">nil</span>, error: error)
</code></pre><p>Moving on, the next method we need to implement is <em>canonicalRequest(for request: URLRequest) -&gt; URLRequest</em>. This method is used to return a canonical version of the request, as described in the <a href="https://developer.apple.com/documentation/foundation/urlprotocol/1408650-canonicalrequest "Apple documentation"">Apple documentation</a>. It's usually enough to return the same request, since we shouldn't make any changes to it, but maybe if you wanted to add a header, or change the URL scheme (for example), it would be a good place to do it. In our case it will be simply:</p><pre><code><span class="keyword">override class func</span> canonicalRequest(for request: <span class="type">URLRequest</span>) -&gt; <span class="type">URLRequest</span> { 
     <span class="keyword">return</span> request
}
</code></pre><p>Then we have to override the <em>startLoading()</em> and <em>stopLoading()</em> methods, which are instance methods. This means that they are executed once it is accepted that it is going to process the request, and the necessary instance will be generated.</p><p>We start with <em>startLoading()</em>. Here when this method is called, the <em>URLProtocolStub</em> implementation should start loading the request:</p><pre><code><span class="keyword">override func</span> startLoading() {
    <span class="keyword">guard let</span> url = request.<span class="property">url</span>, <span class="keyword">let</span> stub = <span class="type">URLProtocolStub</span>.<span class="property">stubs</span>[url] <span class="keyword">else</span> { <span class="keyword">return</span> }
    
    <span class="keyword">if let</span> data = stub.<span class="property">data</span> {
        client?.<span class="call">urlProtocol</span>(<span class="keyword">self</span>, didLoad: data)
    }
    
    <span class="keyword">if let</span> response = stub.<span class="property">response</span> {
        client?.<span class="call">urlProtocol</span>(<span class="keyword">self</span>, didReceive: response, cacheStoragePolicy: .<span class="dotAccess">notAllowed</span>)
    }
    
    <span class="keyword">if let</span> error = stub.<span class="property">error</span> {
        client?.<span class="call">urlProtocol</span>(<span class="keyword">self</span>, didFailWithError: error)
    }
    
    client?.<span class="call">urlProtocolDidFinishLoading</span>(<span class="keyword">self</span>)
}
</code></pre><p>Here, we get the url of the request (where request is an instance variable) and our stub for that url. With the guard let we make sure we have them, and if not, we finish the execution. With the following if statement, if we get an error, we need to tell the URL Loading System that an error occurred, and we do this with another property of the URLProtocol instance, which is the client of type URLProtocolClient. This is an object that the protocol uses to communicate with the URL Loading System. This client has many methods and one of them tells the system that it failed with an error, via <em>urlProtocol(URLProtocol, didFailWithError: Error)</em>.</p><p>We can check in our stub the existence of data, we can tell the client to load "data", through <em>urlProtocol(URLProtocol, didLoad: Data)</em>.</p><p>Similarly, we check for the existence of a "response" , which we will do through <em>urlProtocol(URLProtocol, didReceive: URLResponse, cacheStoragePolicy: URLCache.StoragePolicy)</em>. In this case, we also send the Cache policy, which since we did not deal with it in this post, we will simply send it as .notAllowed. Finally, once we finish we must tell the client that we finished the process, with <em>urlProtocolDidFinishLoading(URLProtocol)</em>.</p><p>The last method we need to implement is stopLoading(), where the stop loading of a request is processed. This could be used to handle a response to a cancellation, for example. In this case, we won't add an implementation, so it will look like this:</p><pre><code><span class="keyword">override func</span> stopLoading() { }
</code></pre><p>It is important to implement it at least empty, otherwise, we will have a crash at runtime. So, we complete the implementation of our stub. It should be like this:</p><pre><code><span class="keyword">private class</span> URLProtocolStub: <span class="type">URLProtocol</span> {
    <span class="keyword">private static var</span> stubs = [<span class="type">URL</span>: <span class="type">Stub</span>]()

    <span class="keyword">private struct</span> Stub {
        <span class="keyword">let</span> data: <span class="type">Data</span>?
        <span class="keyword">let</span> response: <span class="type">URLResponse</span>?
        <span class="keyword">let</span> error: <span class="type">Error</span>?
    }

    <span class="keyword">static func</span> stub(url: <span class="type">URL</span>, data: <span class="type">Data</span>?, response: <span class="type">URLResponse</span>?, error: <span class="type">Error</span>?) {
        stubs[url] = <span class="type">Stub</span>(data: data, response: response, error: error)
    }

    <span class="keyword">static func</span> startInterceptingRequests() {
        <span class="type">URLProtocol</span>.<span class="call">registerClass</span>(<span class="type">URLProtocolStub</span>.<span class="keyword">self</span>)
    }

    <span class="keyword">static func</span> stopInterceptingRequests() {
        <span class="type">URLProtocol</span>.<span class="call">unregisterClass</span>(<span class="type">URLProtocolStub</span>.<span class="keyword">self</span>)
        stubs = [:]
    }

    <span class="keyword">override class func</span> canInit(with request: <span class="type">URLRequest</span>) -&gt; <span class="type">Bool</span> {
        <span class="keyword">guard let</span> url = request.<span class="property">url</span> <span class="keyword">else</span> { <span class="keyword">return false</span> }

        <span class="keyword">return</span> <span class="type">URLProtocolStub</span>.<span class="property">stubs</span>[url] != <span class="keyword">nil</span>
    }

    <span class="keyword">override class func</span> canonicalRequest(for request: <span class="type">URLRequest</span>) -&gt; <span class="type">URLRequest</span> {
        <span class="keyword">return</span> request
    }

    <span class="keyword">override func</span> startLoading() {
        <span class="keyword">guard let</span> url = request.<span class="property">url</span>, <span class="keyword">let</span> stub = <span class="type">URLProtocolStub</span>.<span class="property">stubs</span>[url] <span class="keyword">else</span> { <span class="keyword">return</span> }

        <span class="keyword">if let</span> data = stub.<span class="property">data</span> {
            client?.<span class="call">urlProtocol</span>(<span class="keyword">self</span>, didLoad: data)
        }

        <span class="keyword">if let</span> response = stub.<span class="property">response</span> {
            client?.<span class="call">urlProtocol</span>(<span class="keyword">self</span>, didReceive: response, cacheStoragePolicy: .<span class="dotAccess">notAllowed</span>)
        }

        <span class="keyword">if let</span> error = stub.<span class="property">error</span> {
            client?.<span class="call">urlProtocol</span>(<span class="keyword">self</span>, didFailWithError: error)
        }

        client?.<span class="call">urlProtocolDidFinishLoading</span>(<span class="keyword">self</span>)
    }

    <span class="keyword">override func</span> stopLoading() {}
}
</code></pre><h3>Meeting the requirements: Registering the protocol</h3><p>URLProtocol subclasses are not known to the URL Loading System just because they exist. It is necessary that we register them before a request is made, and thus it will be visible to the system, searching for the different existing protocols and trying to process the request with each one of them. To do this, it is necessary to call the registerClass(AnyClass) class method that registers the protocol. Similarly, we can unsubscribe our URLProtocolStub with the unregisterClass(AnyClass) method. By adding these two lines at the start and end of the test case, we would make it clear to the URL Loading System that we want it to use our Stub. Our test case would look like this:</p><pre><code><span class="keyword">func</span> test_onHTTPClientGetCall_failsOnRequestError() {
    <span class="type">URLProtocol</span>.<span class="call">registerClass</span>(<span class="type">URLProtocolStub</span>.<span class="keyword">self</span>)
    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://any-url.com"</span>)!
    <span class="keyword">let</span> error = <span class="type">NSError</span>(domain: <span class="string">"any error"</span>, code: <span class="number">1</span>)
    <span class="type">URLProtocolStub</span>.<span class="call">stub</span>(url: url, data: <span class="keyword">nil</span>, response: <span class="keyword">nil</span>, error: error)

    <span class="keyword">let</span> sut = <span class="type">URLSessionHTTPClient</span>()

    <span class="keyword">let</span> exp = <span class="call">expectation</span>(description: <span class="string">"Wait for completion"</span>)

    sut.<span class="call">get</span>(from: url) { result <span class="keyword">in
        switch</span> result {
        <span class="keyword">case let</span> .<span class="call">failure</span>(receivedError <span class="keyword">as</span> <span class="type">NSError</span>):
            <span class="call">XCTAssertEqual</span>(receivedError, error)
        <span class="keyword">default</span>:
            <span class="type">XCTFail</span>(<span class="string">"Expected failure with error</span> \(error)<span class="string">, got</span> \(result) <span class="string">instead"</span>)
        }

        exp.<span class="call">fulfill</span>()
    }

    <span class="call">wait</span>(for: [exp], timeout: <span class="number">1.0</span>)
    <span class="type">URLProtocol</span>.<span class="call">unregisterClass</span>(<span class="type">URLProtocolStub</span>.<span class="keyword">self</span>)
}
</code></pre><p>If we run the test case, it should pass without problems. Yay!</p><p>Although we could also add other test cases where we test other ways, as is the case with .success(), it is a good starting point to get into the use of URLProtocol.</p><p>By performing tests in this way, it allows us to avoid assumptions about behaviors that we are mocking in the tests, that may be unpredictable in production, or even that may change in the future, modifying the nature of what we are evaluating. Also, we avoid adding productive code just because we need it for testing, which is usually not a good sign.</p><h4>References</h4><ul><li><a href="https://developer.apple.com/documentation/foundation/urlprotocol/ ">Apple Documentation: URLProtocol</a></li><li><a href="https://developer.apple.com/documentation/foundation/urlsession">Apple Documentation: URLSession</a></li><li><a href="https://developer.apple.com/documentation/foundation/urlsessiondatatask">Apple Documentation: URLSessionDataTask</a></li><li><a href="https://developer.apple.com/documentation/foundation/url_loading_system">Apple Documentation: URL Loading System</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2018/417 ">Testing Tips &amp; Tricks (WWDC 2018)</a></li></ul></div><div class="wrapper post-signature"><p>---</p><p>Hey! Thanks for getting this far! 😊</p><p>Do you see something strange or wrong in this article? It's hosted <a>on Github</a>, you can open a Pull Request for discussion and request an edit. You can also contact me directly <a href="mailto:matiasglessi@gmail.com">here</a>.</p></div></article></div><footer><div class="wrapper section-breaker"><div></div></div><p>Generated in Swift ❤️, using <a href="https://github.com/johnsundell/publish">Publish</a></p><p>© Copyright 2022</p></footer></div></div></body></html>